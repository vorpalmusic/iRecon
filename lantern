#!/bin/bash
# author: JackDaw

## VARIABLE BLOCK
yellow="\e[33m"
blue="\e[34m"
gray="\e[90m"
end="\e[0m"
purple="\e[0;35m\033[1m"

if [ -z "$1" ]; then
    echo -e "\n${yellow}[!]${end} ${purple}Usage:${end} ${blue}$0 <IP>${end}"
    exit 1
fi

target="$1"

# Generating folder structure
BASEDIR="$(pwd)"
MODDIR="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")"/modules >/dev/null 2>&1 && pwd)"
OUTDIR="${BASEDIR}/$target"
mkdir -p "$OUTDIR"

# All scanner/report artifacts go under report/
REPORTDIR="${OUTDIR}/report"
mkdir -p "$REPORTDIR"

echo -e "${yellow}[*]${end} ${purple}Using output directory:${end} ${blue}$OUTDIR${end}"

# Project root = parent of modules; lists live there
ROOTDIR="$(cd -- "$MODDIR/.." && pwd -P)"
LISTDIR="${ROOTDIR}/lists"

### END VARIABLE DECLARATION
### SCRIPT BEGINS THE WORK

"$MODDIR/banner"        ## cue banner

### run fast discovery scan just to find open ports (no live verbose spam)
echo -e "\n${yellow}[*]${end} ${purple}Scanning ports on${end} ${blue}$target${end}${purple}...${end}\n"

sudo /usr/bin/nmap \
  -p- --open -sS -n -Pn \
  --min-rate 2500 \
  --max-retries 0 \
  -T4 \
  -oG "$REPORTDIR/allPorts" \
  "$target" >/dev/null 2>&1

# If greppable file exists, extract ports reliably and print them once
if [ -f "$REPORTDIR/allPorts" ]; then
  discovered_ports=$(grep -oP '\d{1,5}/open' "$REPORTDIR/allPorts" | cut -d'/' -f1 | sort -n -u)

  if [ -n "$discovered_ports" ]; then
    echo -e "${yellow}[*]${end} ${purple}Discovered open ports:${end}"
    while IFS= read -r p; do
      p="${p//[^0-9]/}"
      [ -n "$p" ] && echo "  Discovered open port ${p}/tcp on $target"
    done <<< "$discovered_ports"
  else
    echo -e "${yellow}[!]${end} ${purple}No open ports discovered in greppable output.${end}"
  fi
else
  echo -e "${yellow}[!]${end} ${purple}Nmap greppable output missing: $REPORTDIR/allPorts${end}"
fi

### grab all those ports from the nmap scan and put them in a list
IP="$target"
ports=$(grep -oP '\d{1,5}/open' "$REPORTDIR/allPorts" | cut -d '/' -f1 | xargs | tr ' ' ',')

echo -e "\n${yellow}[*]${end} ${purple}Extracting information...${end}\n" > extractPorts.tmp
echo -e "\t${yellow}[*]${end} ${purple}IP Address:${end} ${blue}$IP${end}" >> extractPorts.tmp
echo -e "\t${yellow}[*]${end} ${purple}Open ports:${end} ${blue}$ports${end}\n" >> extractPorts.tmp
echo "$ports" | tr -d '\n' | xclip -sel clip
echo -e "${yellow}[*]${end} ${purple}Ports copied to clipboard${end}" >> extractPorts.tmp
/usr/bin/batcat --style=plain --paging=never extractPorts.tmp
rm extractPorts.tmp

# --- targeted scan (only if we have ports) ---
if [ -n "$ports" ]; then
  echo -e "\n${yellow}[*]${end} ${purple}Version and Service Scanning...${end}"
  sudo /usr/bin/nmap -sCV -p"$ports" -n -Pn --max-retries 2 --host-timeout 30s "$IP" -A \
       -oN "$REPORTDIR/targeted" -oX "$REPORTDIR/targetedXML" >/dev/null 2>&1
else
  echo -e "${yellow}[!]${end} ${purple}No open ports detected; skipping targeted scan.${end}"
fi

### http-detect
eval "$("$MODDIR/http/http-detect" "$OUTDIR" "$IP")"
echo -e "${yellow}[*]${end} ${purple}HTTP candidates:${end} ${blue}${HTTP_CAND:-<none>}${end}"
echo -e "${yellow}[*]${end} ${purple}Verified HTTP ports:${end} ${blue}${HTTP_VERIFIED:-<none>}${end}"

# --- http-collect for verified HTTP ports (minimal & robust) ---
if [ -n "${HTTP_VERIFIED:-}" ]; then
  for p in $(echo "${HTTP_VERIFIED}" | tr ',' ' '); do
    p="${p//[^0-9]/}"
    [ -z "$p" ] && continue
    "$MODDIR/http/http-collect" "$OUTDIR" "$IP" "$p" >/dev/null 2>&1 || true
  done
fi
# --- end collection ---

# --- show emails we scraped from the HTTP bodies (if any) ---
emails_tmp="$REPORTDIR/.emails.tmp"
: > "$emails_tmp"
if [ -n "${HTTP_VERIFIED:-}" ]; then
  for p in $(echo "${HTTP_VERIFIED}" | tr ',' ' '); do
    f="$OUTDIR/http/$p/emails.txt"
    [ -s "$f" ] && cat "$f" >> "$emails_tmp"
  done
fi
if [ -s "$emails_tmp" ]; then
  emails_sorted="$(sort -u "$emails_tmp")"
  echo -e "${yellow}[*]${end} ${purple}Emails found in page content:${end}"
  while IFS= read -r e; do
    echo -e "   ${blue}${e}${end}"
  done <<< "$emails_sorted"
fi
rm -f "$emails_tmp"
# --- end emails summary ---

# Passive enrichment
target_hint="${HTTP_CAND:-$IP}"
found_hosts="$("$MODDIR/http/enrich" "$OUTDIR" "$target_hint" --max 200)"
echo -e "${yellow}[*]${end} ${purple}Passive hosts found:${end}"
echo "$found_hosts" | sed '/^$/d' | while IFS= read -r h; do
  echo -e "   ${blue}$h${end}"
done

# --- Add /etc/hosts entries ONCE (denylist-aware) ---
added="$(sudo bash "$MODDIR/http/add-hosts" "$OUTDIR" "$IP" "${HTTP_VERIFIED:-}" --deny-file "$LISTDIR/deny-domains")"
if [ -n "$added" ]; then
  echo -e "${yellow}[*]${end} ${purple}Hosts added to /etc/hosts:${end}"
  echo "$added"
else
  echo -e "${yellow}[*]${end} ${purple}No new /etc/hosts entries needed.${end}"
fi

# --- Generate HTML report (with safe fallback) ---
# Try Nmap XSLT â†’ if it fails or stylesheet missing, create a minimal stub.
: "${NMAP_XSL:=/usr/share/nmap/nmap.xsl}"
if [ ! -f "$NMAP_XSL" ]; then
  NMAP_XSL="$(find /usr/local/share /usr/share /opt -type f -name nmap.xsl 2>/dev/null | head -n1 || true)"
fi

make_stub_report() {
  cat > "$REPORTDIR/index.html" <<'HTML'
<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>Lantern Report</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;margin:24px;max-width:1100px}h1{margin:0 0 .25em}hr{margin:1.5em 0}</style>
<h1>Lantern Report</h1>
<p>This is a minimal report stub. Module summaries are appended below.</p>
<hr>
HTML
}

report_ready=false
if [ -s "$REPORTDIR/targetedXML" ] && [ -n "$NMAP_XSL" ] && [ -f "$NMAP_XSL" ] && command -v xsltproc >/dev/null 2>&1; then
  if xsltproc -o "$REPORTDIR/index.html" "$NMAP_XSL" "$REPORTDIR/targetedXML" >/dev/null 2>&1; then
    report_ready=true
  else
    echo "[!] xsltproc failed; falling back to minimal HTML stub"
  fi
else
  echo "[!] nmap.xsl not found or xsltproc missing; creating minimal HTML stub"
fi

if [ "$report_ready" != true ]; then
  make_stub_report
fi

# >>> Append Lantern module summary via reporter <<<
rep="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")"/scripts >/dev/null 2>&1 && pwd)/reporter"
if [ -f "$rep" ]; then
  bash "$rep" "$OUTDIR" || echo "[!] reporter failed"
else
  echo "[!] reporter not found; skipping module summary"
fi

# Launch a tiny HTTP server to view the report, then exit (server left running in background)
# serve localhost only on port 9999
# wait briefly for report/index.html to appear (fast loop)
for i in $(seq 1 50); do
  [ -s "$REPORTDIR/index.html" ] && break
  sleep 0.1
done

if [ -s "$REPORTDIR/index.html" ]; then
  # Resolve the *actual* directory that contains index.html and serve from there.
  SRVFILE="$(realpath "$REPORTDIR/index.html")"
  SRVDIR="$(dirname "$SRVFILE")"

  # Start a local HTTP server rooted at SRVDIR with directory listing disabled.
  # This avoids relying on --directory/-d flags and prevents browsing outside index.html.
  python3 - "$SRVDIR" >/dev/null 2>&1 <<'PY' &
import os, sys, http.server, socketserver
root = sys.argv[1]
os.chdir(root)

class NoListHandler(http.server.SimpleHTTPRequestHandler):
    # Prevent directory listings even if someone hits the root or a folder directly.
    def list_directory(self, path):
        self.send_error(404, "Directory listing disabled")
        return None

# Bind only to localhost on the chosen port.
with socketserver.ThreadingTCPServer(("127.0.0.1", 9999), NoListHandler) as httpd:
    httpd.serve_forever()
PY
  server_pid=$!
  disown "$server_pid" 2>/dev/null || true

  url="http://127.0.0.1:9999/report/index.html"
  echo -e "${yellow}[*]${end} ${purple}Report:${end} ${blue}$url${end}"
  ( xdg-open "$url" >/dev/null 2>&1 || /usr/bin/firefox "$url" >/dev/null 2>&1 ) &
else
  echo "[!] index.html not found after fallback; not starting web server"
fi

exit 0

#!/usr/bin/env bash
# add-hosts — append missing "IP hostname" pairs from Nmap XML + HTTP probes to /etc/hosts
# Usage:
#   add-hosts OUTDIR IP [PORTS] [--dry-run] [--allow-regex '<regex>'] [--deny-file <path>] [--verbose]

set -euo pipefail

DRY_RUN=0

# Upsert one host into /etc/hosts (update if host exists, else join same-IP line, else append)
# Case-insensitive for hostnames; ignores trailing dot; preserves alias order/case; no backups.
# Usage: upsert_host_entry <ip> <host> [alias1 alias2 ...]
upsert_host_entry() {
  local ip="$1"; shift
  local host="$1"; shift
  local extras=("$@")

  # Build space-separated extras with original casing; we’ll compare in lowercase
  local alias_str=""
  if ((${#extras[@]})); then alias_str="${extras[*]}"; fi

  # In dry-run mode, just print what we *would* do and bail early.
  if [ "${DRY_RUN:-0}" -eq 1 ]; then
    echo "[dry-run] would ensure ${host} → ${ip} (extras: ${alias_str})"
    return 0
  fi

  awk -v target_ip="$ip" -v target_host="$host" -v alias_str="$alias_str" '
  BEGIN{
    # normalize target_host (lowercase, strip trailing dot)
    th = tolower(target_host); sub(/\.$/, "", th)

    # track desired extra aliases (keyed by lowercase; store original form)
    split(alias_str, tmp, /[ \t]+/)
    for (i in tmp) {
      if (length(tmp[i])) {
        k = tolower(tmp[i]); sub(/\.$/, "", k)
        want[k] = tmp[i]
      }
    }

    N = 0
    host_line = 0
    ip_line = 0
  }

  # Parse and store all lines for a second-phase decision
  {
    orig = $0
    sub(/\r$/,"",orig)
    N++
    raw[N] = orig

    # default: passthrough line
    afters[N] = ""

    # Comments / blanks
    if (orig ~ /^[ \t]*#/ || orig ~ /^[ \t]*$/) next

    # split off trailing inline comment to preserve
    ci = index(orig, "#")
    if (ci > 0) { before = substr(orig, 1, ci-1); afters[N] = substr(orig, ci) }
    else        { before = orig;                          afters[N] = "" }

    # tokenize before-comment section
    n = split(before, f, /[ \t]+/)
    i0 = 1; while (i0 <= n && f[i0] == "") i0++
    if (i0 > n) next

    # first token is IP; store
    ips[N] = f[i0]

    # collect names (preserve order & original case)
    k = 0
    delete seen; delete order; delete order_lc
    for (i = i0+1; i <= n; i++) {
      if (f[i] == "") continue
      key = tolower(f[i]); sub(/\.$/, "", key)
      if (!(key in seen)) {
        seen[key] = 1
        k++
        order[k] = f[i]
        order_lc[k] = key
      }
    }
    counts[N] = k
    for (i = 1; i <= k; i++) names[N, i] = order[i]
    for (i = 1; i <= k; i++) names_lc[N, i] = order_lc[i]

    # Did we see the target host on this line?
    for (i = 1; i <= k; i++) {
      if (names_lc[N, i] == th) {
        if (host_line == 0) host_line = N
      }
    }

    # Remember first line with the target IP (for join-if-no-host case)
    if (ip_line == 0 && ips[N] == target_ip) ip_line = N
  }

  END{
    # CASE A: host already exists somewhere → update that line to target_ip (keep aliases, add extras)
    if (host_line > 0) {
      for (i = 1; i <= N; i++) {
        if (i == host_line) {
          delete seen; for (j = 1; j <= counts[i]; j++) { key = tolower(names[i, j]); sub(/\.$/, "", key); seen[key] = 1 }

          printf "%s", target_ip
          for (j = 1; j <= counts[i]; j++) printf " %s", names[i, j]

          for (k in want) if (!(k in seen)) printf " %s", want[k]

          if (afters[i] != "") printf " %s", afters[i]
          printf "\n"
        } else {
          print raw[i]
        }
      }
      exit 0
    }

    # CASE B: host not present; there is a line with the same IP → add host (and extras) to that line
    if (ip_line > 0) {
      for (i = 1; i <= N; i++) {
        if (i == ip_line) {
          delete seen; for (j = 1; j <= counts[i]; j++) { key = tolower(names[i, j]); sub(/\.$/, "", key); seen[key] = 1 }

          printf "%s", ips[i]
          for (j = 1; j <= counts[i]; j++) printf " %s", names[i, j]

          if (!(th in seen)) printf " %s", target_host
          seen[th] = 1

          for (k in want) if (!(k in seen)) printf " %s", want[k]

          if (afters[i] != "") printf " %s", afters[i]
          printf "\n"
        } else {
          print raw[i]
        }
      }
      exit 0
    }

    # CASE C: no host, no same-IP line → append a new line at EOF
    for (i = 1; i <= N; i++) print raw[i]
    printf "%s %s", target_ip, target_host
    for (k in want) printf " %s", want[k]
    printf "\n"
  }
  ' /etc/hosts | sudo tee /etc/hosts >/dev/null
}

if [ "$#" -lt 2 ]; then
  echo "Usage: $0 OUTDIR IP [PORTS] [--dry-run] [--allow-regex '<regex>'] [--deny-file <path>] [--verbose]" >&2
  exit 2
fi

OUTDIR="$1"; IP="$2"
PORTS_ARG="${3:-}"

# shift off OUTDIR/IP; leave PORTS if present (we’ll re-read it from $3)
shift 2
ARGS=("$@")

ALLOW_REGEX=""
VERBOSE=0

# default deny file: modules/http/add-hosts → ../../lists/deny-domains
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
DENY_FILE_DEFAULT="$SCRIPT_DIR/../../lists/deny-domains"
DENY_FILE="${ADD_HOSTS_DENY:-$DENY_FILE_DEFAULT}"

# parse tail flags (leave PORTS_ARG as-is)
i=0
while [ $i -lt "${#ARGS[@]}" ]; do
  a="${ARGS[$i]}"
  case "$a" in
    --dry-run)      DRY_RUN=1; i=$((i+1));;
    --allow-regex)  i=$((i+1)); ALLOW_REGEX="${ARGS[$i]:-}"; i=$((i+1));;
    --deny-file)    i=$((i+1)); DENY_FILE="${ARGS[$i]:-}"; i=$((i+1));;
    --verbose)      VERBOSE=1; i=$((i+1));;
    *)              i=$((i+1));;  # ignore unknown tail args
  esac
done

# XML now comes from OUTDIR/report/
xml="$OUTDIR/report/targetedXML"
DOMAIN_RE='([a-zA-Z0-9][-a-zA-Z0-9]*\.)+[a-zA-Z]{2,}'

# ---- load denylist file (optional) ----
DENY_PATTERNS=()
if [ -f "$DENY_FILE" ]; then
  while IFS= read -r line; do
    line="${line%%#*}"
    line="$(echo -n "$line" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
    [ -z "$line" ] && continue
    DENY_PATTERNS+=("$line")
  done < "$DENY_FILE"
else
  [ $VERBOSE -eq 1 ] && echo "[info] deny file not found: $DENY_FILE (no denylist applied)" >&2
fi

is_denied() {
  local host="$1" pat
  shopt -s nocasematch 2>/dev/null || true
  for pat in "${DENY_PATTERNS[@]}"; do
    if [[ "$host" =~ $pat ]]; then
      return 0
    fi
  done
  return 1
}

declare -A map=()   # name -> ip

# ---------- 1) Extract from XML (Nmap) ----------
if command -v xmlstarlet >/dev/null 2>&1; then
  if [ -s "$xml" ]; then
    while IFS= read -r line; do
      ippart="${line%% *}"
      namespart="${line#* }"
      for nm in $namespart; do
        [[ -z "$nm" ]] && continue
        [[ "$nm" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue
        if [ -n "$ALLOW_REGEX" ] && ! [[ "$nm" =~ $ALLOW_REGEX ]]; then
          [ $VERBOSE -eq 1 ] && echo "[skip] $nm (allow-regex rejects)" >&2; continue
        fi
        if is_denied "$nm"; then
          [ $VERBOSE -eq 1 ] && echo "[deny] $nm (denylist)" >&2; continue
        fi
        [[ -z "${map[$nm]+x}" ]] && map["$nm"]="$ippart"
      done
    done < <(
      xmlstarlet sel -t -m "//host[status/@state='up']" \
        -v "address/@addr" -o " " \
        -m "hostnames/hostname" -v "@name" -o " " -b -n "$xml" 2>/dev/null \
      | sed -E 's/[[:space:]]+/ /g; s/ $//'
    )
  else
    [ $VERBOSE -eq 1 ] && echo "[info] XML file missing or empty: $xml" >&2
  fi
else
  [ $VERBOSE -eq 1 ] && echo "[info] xmlstarlet not installed; skipping Nmap hostname extraction" >&2
fi

# ---------- 2) Probe provided ports for hostnames ----------
probe_ports_to_names() {
  local ip="$1" ports="$2"
  local -a found=()
  ports="${ports//,/ }"
  for p in $ports; do
    p="${p//[^0-9]/}"; [ -z "$p" ] && continue
    headers="$(curl -sI --max-time 5 "http://$ip:$p/" 2>/dev/null || true)"
    [ -z "$headers" ] && headers="$(curl -k -sI --max-time 5 "https://$ip:$p/" 2>/dev/null || true)"

    # Location headers → hostnames
    while IFS= read -r loc; do
      host="$(echo "$loc" | sed -nE "s/Location:[[:space:]]*https?:\/\/($DOMAIN_RE)(.+)?/\1/ip; t; s/.*Location:[[:space:]]*([a-zA-Z0-9.-]+).*/\1/p" | tr -d '\r')"
      [ -n "$host" ] && [[ "$host" =~ $DOMAIN_RE ]] && found+=("$host")
    done < <(echo "$headers" | grep -i '^Location:' || true)

    # body
    body="$(curl -sL --max-time 6 "http://$ip:$p/" 2>/dev/null || true)"
    [ -z "$body" ] && body="$(curl -k -sL --max-time 6 "https://$ip:$p/" 2>/dev/null || true)"

    if [ -n "$body" ]; then
      # Just grab hostnames from absolute URLs in the body
      while IFS= read -r token; do
        hosttok="$(echo "$token" | sed -nE "s#https?://($DOMAIN_RE).*#\1#Ip")"
        [ -n "$hosttok" ] && found+=("$hosttok")
      done < <(printf '%s\n' "$body" | grep -oE "https?://[^\"' ><]+" || true)
    fi

    # TLS SANs for common TLS-ish ports or when we see HSTS
    if [[ "$p" =~ ^(443|8443|9443)$ ]] || echo "$headers" | grep -qi 'strict-transport-security'; then
      cert_txt="$(timeout 4 openssl s_client -connect "$ip:$p" -servername "$ip" </dev/null 2>/dev/null | openssl x509 -noout -text 2>/dev/null || true)"
      if [ -n "$cert_txt" ]; then
        while IFS= read -r sanline; do
          san="$(echo "$sanline" | sed -nE "s/.*DNS:($DOMAIN_RE).*/\1/Ip")"
          [ -n "$san" ] && found+=("$san")
        done < <(echo "$cert_txt" | grep -i 'DNS:' || true)
      fi
    fi
  done

  if [ "${#found[@]}" -gt 0 ]; then
    printf "%s\n" "${found[@]}" | awk '!x[$0]++{print}'
  fi
}

if [ -n "${PORTS_ARG:-}" ]; then
  probe_names="$(probe_ports_to_names "$IP" "$PORTS_ARG" || true)"
  if [ -n "$probe_names" ]; then
    while IFS= read -r nm; do
      [[ -z "$nm" ]] && continue
      [[ "$nm" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue
      if [ -n "$ALLOW_REGEX" ] && ! [[ "$nm" =~ $ALLOW_REGEX ]]; then
        [ $VERBOSE -eq 1 ] && echo "[skip] $nm (allow-regex rejects)" >&2; continue
      fi
      if is_denied "$nm"; then
        [ $VERBOSE -eq 1 ] && echo "[deny] $nm (denylist)" >&2; continue
      fi
      [[ -z "${map[$nm]+x}" ]] && map["$nm"]="$IP"
    done <<< "$probe_names"
  fi
fi

# --- harvest domains from http-collected emails and verify via Host header ---
if [ -n "${PORTS_ARG:-}" ]; then
  email_domains_file="$(mktemp)"
  trap 'rm -f "$email_domains_file"' EXIT
  while IFS= read -r ef; do
    [ -s "$ef" ] || continue
    awk -F'@' '{if (NF>=2) print $NF}' "$ef" \
      | tr 'A-Z' 'a-z' \
      | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' \
      >> "$email_domains_file"
  done < <(find "$OUTDIR/http" -maxdepth 2 -type f -name 'emails.txt' 2>/dev/null || true)

  if [ -s "$email_domains_file" ]; then
    while IFS= read -r dom; do
      [[ -z "$dom" ]] && continue
      verified_hit=0
      for p in $(echo "$PORTS_ARG" | tr ',' ' '); do
        p="${p//[^0-9]/}"; [ -z "$p" ] && continue
        if curl -sI --max-time 4 -H "Host: $dom" "http://$IP:$p/" | head -n1 | grep -qE 'HTTP/[0-9.]+\ [12][0-9]{2}|HTTP/[0-9.]+\ 3[0-9]{2}'; then
          verified_hit=1
          break
        fi
      done
      if [ "$verified_hit" -eq 1 ]; then
        if [ -n "$ALLOW_REGEX" ] && ! [[ "$dom" =~ $ALLOW_REGEX ]]; then
          [ $VERBOSE -eq 1 ] && echo "[skip] $dom (allow-regex rejects)" >&2
          continue
        fi
        if is_denied "$dom"; then
          [ $VERBOSE -eq 1 ] && echo "[deny] $dom (denylist)" >&2
          continue
        fi
        [[ -z "${map[$dom]+x}" ]] && map["$dom"]="$IP"
      fi
    done < <(sort -u "$email_domains_file")
  fi
fi
# --- end email-domain verification ---

[ "${#map[@]}" -eq 0 ] && exit 0

for name in "${!map[@]}"; do
  ip="${map[$name]}"
  [[ "$name" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue

  if upsert_host_entry "$ip" "$name"; then
    [ "$DRY_RUN" -eq 0 ] && echo "Ensured ${name} → ${ip}"
  else
    echo "ERROR: failed to upsert '${name}' into /etc/hosts (sudo?)" >&2
    exit 1
  fi
done

exit 0

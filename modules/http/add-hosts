#!/usr/bin/env bash
# add-hosts — append missing "IP hostname" pairs from Nmap outputs or HTTP probes to /etc/hosts
# Usage:
#   add-hosts OUTDIR IP [PORTS] [--dry-run] [--allow-regex '<regex>'] [--deny-file <path>] [--verbose]

# Upsert one host into /etc/hosts (update if host exists, else join same-IP line, else append)
# Case-insensitive for hostnames; ignores trailing dot; preserves alias order/case; no backups.
# Usage: upsert_host_entry <ip> <host> [alias1 alias2 ...]
upsert_host_entry() {
  local ip="$1"; shift
  local host="$1"; shift
  local extras=("$@")

  # Build space-separated extras with original casing; we’ll compare in lowercase
  local alias_str=""
  if ((${#extras[@]})); then alias_str="${extras[*]}"; fi

  awk -v target_ip="$ip" -v target_host="$host" -v alias_str="$alias_str" '
  BEGIN{
    # normalize target_host (lowercase, strip trailing dot)
    th = tolower(target_host); sub(/\.$/, "", th)

    # track desired extra aliases (keyed by lowercase; store original form)
    split(alias_str, tmp, /[ \t]+/)
    for (i in tmp) {
      if (length(tmp[i])) {
        k = tolower(tmp[i]); sub(/\.$/, "", k)
        want[k] = tmp[i]
      }
    }

    N = 0
    host_line = 0
    ip_line = 0
  }

  # Parse and store all lines for a second-phase decision
  {
    orig = $0
    sub(/\r$/,"",orig)                                    # just in case
    N++
    raw[N] = orig

    # default: passthrough line
    types[N] = "pass"
    afters[N] = ""

    # Comments / blanks
    if (orig ~ /^[ \t]*#/ || orig ~ /^[ \t]*$/) next

    # split off trailing inline comment to preserve
    ci = index(orig, "#")
    if (ci > 0) { before = substr(orig, 1, ci-1); afters[N] = substr(orig, ci) }
    else        { before = orig;                          afters[N] = "" }

    # tokenize before-comment section
    n = split(before, f, /[ \t]+/)
    i0 = 1; while (i0 <= n && f[i0] == "") i0++
    if (i0 > n) next

    # first token is IP; store
    ips[N] = f[i0]

    # collect names (preserve order & original case)
    k = 0
    delete seen; delete order; delete order_lc
    for (i = i0+1; i <= n; i++) {
      if (f[i] == "") continue
      key = tolower(f[i]); sub(/\.$/, "", key)
      if (!(key in seen)) {
        seen[key] = 1
        k++
        order[k] = f[i]
        order_lc[k] = key
      }
    }
    counts[N] = k
    for (i = 1; i <= k; i++) names[N, i] = order[i]
    for (i = 1; i <= k; i++) names_lc[N, i] = order_lc[i]

    # Did we see the target host on this line?
    for (i = 1; i <= k; i++) {
      if (names_lc[N, i] == th) {
        if (host_line == 0) host_line = N
      }
    }

    # Remember first line with the target IP (for join-if-no-host case)
    if (ip_line == 0 && ips[N] == target_ip) ip_line = N
  }

  END{
    # CASE A: host already exists somewhere → update that line to target_ip (keep aliases, add extras)
    if (host_line > 0) {
      for (i = 1; i <= N; i++) {
        if (i == host_line) {
          # build a presence set of existing aliases (lowercased sans trailing dot)
          delete seen; for (j = 1; j <= counts[i]; j++) { key = tolower(names[i, j]); sub(/\.$/, "", key); seen[key] = 1 }

          # print new IP + original aliases in original order
          printf "%s", target_ip
          for (j = 1; j <= counts[i]; j++) printf " %s", names[i, j]

          # append wanted extras if missing
          for (k in want) if (!(k in seen)) printf " %s", want[k]

          if (afters[i] != "") printf " %s", afters[i]
          printf "\n"
        } else {
          print raw[i]
        }
      }
      exit 0
    }

    # CASE B: host not present; there is a line with the same IP → add host (and extras) to that line
    if (ip_line > 0) {
      for (i = 1; i <= N; i++) {
        if (i == ip_line) {
          delete seen; for (j = 1; j <= counts[i]; j++) { key = tolower(names[i, j]); sub(/\.$/, "", key); seen[key] = 1 }

          printf "%s", ips[i]
          for (j = 1; j <= counts[i]; j++) printf " %s", names[i, j]

          # ensure target_host present (use original casing as provided)
          if (!(th in seen)) printf " %s", target_host
          seen[th] = 1

          # append extras not already present
          for (k in want) if (!(k in seen)) printf " %s", want[k]

          if (afters[i] != "") printf " %s", afters[i]
          printf "\n"
        } else {
          print raw[i]
        }
      }
      exit 0
    }

    # CASE C: no host, no same-IP line → append a new line at EOF
    for (i = 1; i <= N; i++) print raw[i]
    printf "%s %s", target_ip, target_host
    for (k in want) printf " %s", want[k]
    printf "\n"
  }
  ' /etc/hosts | sudo tee /etc/hosts >/dev/null
}

set -euo pipefail

if [ "$#" -lt 2 ]; then
  echo "Usage: $0 OUTDIR IP [PORTS] [--dry-run] [--allow-regex '<regex>'] [--deny-file <path>] [--verbose]" >&2
  exit 2
fi

OUTDIR="$1"; IP="$2"
PORTS_ARG="${3:-}"

# shift off OUTDIR/IP; leave PORTS if present (we’ll re-read it from $3)
shift 2
ARGS=("$@")

DRY_RUN=0
ALLOW_REGEX=""
VERBOSE=0

# default deny file: alongside this script, or env override
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
DENY_FILE_DEFAULT="$SCRIPT_DIR/../lists/deny-domains"
DENY_FILE="${ADD_HOSTS_DENY:-$DENY_FILE_DEFAULT}"

# parse tail flags (leave PORTS_ARG as-is)
i=0
while [ $i -lt "${#ARGS[@]}" ]; do
  a="${ARGS[$i]}"
  case "$a" in
    --dry-run) DRY_RUN=1; i=$((i+1));;
    --allow-regex) i=$((i+1)); ALLOW_REGEX="${ARGS[$i]:-}"; i=$((i+1));;
    --deny-file)   i=$((i+1)); DENY_FILE="${ARGS[$i]:-}"; i=$((i+1));;
    --verbose) VERBOSE=1; i=$((i+1));;
    *) i=$((i+1));;  # ignore unknown tail args
  esac
done

xml="$OUTDIR/targetedXML"
txt="$OUTDIR/targeted"
DOMAIN_RE='([a-zA-Z0-9][-a-zA-Z0-9]*\.)+[a-zA-Z]{2,}'

# ---- load denylist file (optional) ----
DENY_PATTERNS=()
if [ -f "$DENY_FILE" ]; then
  # strip comments/blank lines
  while IFS= read -r line; do
    line="${line%%#*}"; line="$(echo -n "$line" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
    [ -z "$line" ] && continue
    DENY_PATTERNS+=("$line")
  done < "$DENY_FILE"
else
  [ $VERBOSE -eq 1 ] && echo "[info] deny file not found: $DENY_FILE (no denylist applied)" >&2
fi

is_denied() {
  local host="$1" pat
  shopt -s nocasematch 2>/dev/null || true
  for pat in "${DENY_PATTERNS[@]}"; do
    if [[ "$host" =~ $pat ]]; then
      return 0
    fi
  done
  return 1
}

declare -A map=()   # name -> ip

# ---------- 1) Extract from XML ----------
if command -v xmlstarlet >/dev/null 2>&1 && [ -s "$xml" ]; then
  while IFS= read -r line; do
    ippart="${line%% *}"
    namespart="${line#* }"
    for nm in $namespart; do
      [[ -z "$nm" ]] && continue
      [[ "$nm" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue
      if [ -n "$ALLOW_REGEX" ] && ! [[ "$nm" =~ $ALLOW_REGEX ]]; then
        [ $VERBOSE -eq 1 ] && echo "[skip] $nm (allow-regex rejects)" >&2; continue
      fi
      if is_denied "$nm"; then
        [ $VERBOSE -eq 1 ] && echo "[deny] $nm (denylist)" >&2; continue
      fi
      [[ -z "${map[$nm]+x}" ]] && map["$nm"]="$ippart"
    done
  done < <(
    xmlstarlet sel -t -m "//host[status/@state='up']" \
      -v "address/@addr" -o " " \
      -m "hostnames/hostname" -v "@name" -o " " -b -n "$xml" 2>/dev/null \
    | sed -E 's/[[:space:]]+/ /g; s/ $//'
  )
fi

# ---------- 2) Fallback: parse targeted text ----------
if [ "${#map[@]}" -eq 0 ] && [ -s "$txt" ]; then
  while IFS= read -r line; do
    if [[ "$line" =~ ^Nmap\ scan\ report\ for\ ([^[:space:]]+)\ \(([0-9\.]+)\) ]]; then
      name="${BASH_REMATCH[1]}"; ip="${BASH_REMATCH[2]}"
      [[ -z "$name" ]] && continue
      if [ -n "$ALLOW_REGEX" ] && ! [[ "$name" =~ $ALLOW_REGEX ]]; then
        [ $VERBOSE -eq 1 ] && echo "[skip] $name (allow-regex rejects)" >&2; continue
      fi
      if is_denied "$name"; then
        [ $VERBOSE -eq 1 ] && echo "[deny] $name (denylist)" >&2; continue
      fi
      [[ -z "${map[$name]+x}" ]] && map["$name"]="$ip"
    fi
  done < "$txt"
fi

# ---------- 3) Probe provided ports for hostnames ----------
probe_ports_to_names() {
  local ip="$1" ports="$2"
  local -a found=()
  ports="${ports//,/ }"
  for p in $ports; do
    p="${p//[^0-9]/}"; [ -z "$p" ] && continue
    headers="$(curl -sI --max-time 5 "http://$ip:$p/" 2>/dev/null || true)"
    [ -z "$headers" ] && headers="$(curl -k -sI --max-time 5 "https://$ip:$p/" 2>/dev/null || true)"

    # Location headers
    while IFS= read -r loc; do
      host="$(echo "$loc" | sed -nE 's/Location:[[:space:]]*https?:\/\/('"$DOMAIN_RE"')(.+)?/\1/ip; t; s/.*Location:[[:space:]]*([a-zA-Z0-9.-]+).*/\1/p' | tr -d '\r')"
      [ -n "$host" ] && [[ "$host" =~ $DOMAIN_RE ]] && found+=("$host")
    done < <(echo "$headers" | grep -i '^Location:' || true)

    # body
    body="$(curl -sL --max-time 6 "http://$ip:$p/" 2>/dev/null || true)"
    [ -z "$body" ] && body="$(curl -k -sL --max-time 6 "https://$ip:$p/" 2>/dev/null || true)"

    if [ -n "$body" ]; then
      host_from_canon="$(echo "$body" | tr '\n' ' ' | \
        grep -oP '(?i)<link[^>]+rel=["'\'']canonical["'\''][^>]*>' | \
        grep -oP 'href=["'\'']\K[^"'\'' ]+' | sed -nE 's#https?://('"$DOMAIN_RE"').*#\1#ip; s/.*//p' | sed -n 's/^$//')"
      [ -n "$host_from_canon" ] && found+=("$host_from_canon")

      while IFS= read -r token; do
        hosttok="$(echo "$token" | sed -nE 's#https?://('"$DOMAIN_RE"').*#\1#ip; s/.*//p')"
        [ -n "$hosttok" ] && found+=("$hosttok")
      done < <(echo "$body" | grep -oE 'https?://[^"'\'' ><]+' || true)
    fi

    # TLS SANs for common TLS ports
    if [[ "$p" =~ ^(443|8443|9443)$ ]] || echo "$headers" | grep -qi 'strict-transport-security'; then
      cert_txt="$(timeout 4 openssl s_client -connect "$ip:$p" -servername "$ip" </dev/null 2>/dev/null | openssl x509 -noout -text 2>/dev/null || true)"
      if [ -n "$cert_txt" ]; then
        while IFS= read -r sanline; do
          san="$(echo "$sanline" | sed -nE 's/.*DNS:('"$DOMAIN_RE"').*/\1/ip; s/.*//p')"
          [ -n "$san" ] && found+=("$san")
        done < <(echo "$cert_txt" | grep -i 'DNS:' || true)
      fi
    fi
  done

  # dedupe
  if [ "${#found[@]}" -gt 0 ]; then
    printf "%s\n" "${found[@]}" | awk '!x[$0]++{print}'
  fi
}

if [ -n "${PORTS_ARG:-}" ]; then
  probe_names="$(probe_ports_to_names "$IP" "$PORTS_ARG" || true)"
  if [ -n "$probe_names" ]; then
    while IFS= read -r nm; do
      [[ -z "$nm" ]] && continue
      [[ "$nm" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue
      if [ -n "$ALLOW_REGEX" ] && ! [[ "$nm" =~ $ALLOW_REGEX ]]; then
        [ $VERBOSE -eq 1 ] && echo "[skip] $nm (allow-regex rejects)" >&2; continue
      fi
      if is_denied "$nm"; then
        [ $VERBOSE -eq 1 ] && echo "[deny] $nm (denylist)" >&2; continue
      fi
      [[ -z "${map[$nm]+x}" ]] && map["$nm"]="$IP"
    done <<< "$probe_names"
  fi
fi

# --- harvest domains from http-collected emails and verify via Host header ---
# Only if ports were provided (we need them to verify vhost)
if [ -n "${PORTS_ARG:-}" ]; then
  email_domains_file="$(mktemp)"; trap 'rm -f "$email_domains_file"' RETURN
  # collect domains from emails under OUTDIR/http/*/emails.txt
  while IFS= read -r ef; do
    [ -s "$ef" ] || continue
    # pull domain part of emails
    awk -F'@' '{if (NF>=2) print $NF}' "$ef" \
      | tr 'A-Z' 'a-z' \
      | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' \
      >> "$email_domains_file"
  done < <(find "$OUTDIR/http" -maxdepth 2 -type f -name 'emails.txt' 2>/dev/null || true)

  if [ -s "$email_domains_file" ]; then
    # dedupe domains
    while IFS= read -r dom; do
      [[ -z "$dom" ]] && continue
      # verify domain against provided ports via Host header
      verified_hit=0
      for p in $(echo "$PORTS_ARG" | tr ',' ' '); do
        p="${p//[^0-9]/}"; [ -z "$p" ] && continue
        # success if we get any HTTP status < 400 quickly
        if curl -sI --max-time 4 -H "Host: $dom" "http://$IP:$p/" | head -n1 | grep -qE 'HTTP/[0-9.]+\ [12][0-9]{2}|HTTP/[0-9.]+\ 3[0-9]{2}'; then
          verified_hit=1
          break
        fi
      done
      if [ "$verified_hit" -eq 1 ]; then
        # optional: allow/deny tests if you kept those flags
        if [ -n "$ALLOW_REGEX" ] && ! [[ "$dom" =~ $ALLOW_REGEX ]]; then
          [ $VERBOSE -eq 1 ] && echo "[skip] $dom (allow-regex rejects)" >&2
          continue
        fi
        if command -v is_denied >/dev/null 2>&1 && is_denied "$dom"; then
          [ $VERBOSE -eq 1 ] && echo "[deny] $dom (denylist)" >&2
          continue
        fi
        # store mapping (domain -> IP) if not present
        [[ -z "${map[$dom]+x}" ]] && map["$dom"]="$IP"
      fi
    done < <(sort -u "$email_domains_file")
  fi
fi
# --- end email-domain verification ---

# Nothing to add
[ "${#map[@]}" -eq 0 ] && exit 0

# Upsert entries (update IP if host exists; preserve aliases; append if absent)
for name in "${!map[@]}"; do
  ip="${map[$name]}"
  [[ "$name" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue

  if upsert_host_entry "$ip" "$name"; then
    echo "Ensured ${name} → ${ip}"
  else
    echo "ERROR: failed to upsert '${name}' into /etc/hosts (sudo?)" >&2
    exit 1
  fi
done

exit 0
